# NOTE: This is a template file. In production, secrets should be managed
# through sealed-secrets, external-secrets, or your cloud provider's secret manager.

apiVersion: v1
kind: Secret
metadata:
  name: sitespeak-secrets
  namespace: sitespeak
type: Opaque
stringData:
  OPENAI_API_KEY: "sk-replace-with-actual-key"
  JWT_SECRET: "replace-with-32-plus-character-secret"
  ENCRYPTION_KEY: "32-character-encryption-key-here"
  DATABASE_URL: "postgresql://user:password@postgres-service:5432/sitespeak"
  REDIS_URL: "redis://redis-service:6379"

  # CDN and Storage secrets
  CLOUDFLARE_API_TOKEN: "replace-with-cloudflare-token"
  CLOUDFLARE_ZONE_ID: "replace-with-zone-id"
  AWS_ACCESS_KEY_ID: "replace-with-aws-key"
  AWS_SECRET_ACCESS_KEY: "replace-with-aws-secret"

  # Additional API keys
  WEBHOOK_SECRET: "replace-with-webhook-secret"
  SESSION_SECRET: "replace-with-session-secret"

---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
  namespace: sitespeak
type: Opaque
stringData:
  POSTGRES_PASSWORD: "replace-with-postgres-password"
  POSTGRES_USER: "sitespeak"
  POSTGRES_DB: "sitespeak_production"

---
apiVersion: v1
kind: Secret
metadata:
  name: redis-secret
  namespace: sitespeak
type: Opaque
stringData:
  REDIS_PASSWORD: "replace-with-redis-password"

---
# TLS certificate for HTTPS
apiVersion: v1
kind: Secret
metadata:
  name: sitespeak-tls
  namespace: sitespeak
type: kubernetes.io/tls
data:
  # Base64 encoded certificate and key
  # In production, use cert-manager with Let's Encrypt
  tls.crt: LS0tLS1CRUdJTi... # Replace with actual certificate
  tls.key: LS0tLS1CRUdJTi... # Replace with actual private key